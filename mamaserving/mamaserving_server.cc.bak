#include "ModelSliceReader.h"
#include "alimama.grpc.pb.h"
#include "alimama.pb.h"
#include "collab.grpc.pb.h"
#include "collab.pb.h"
#include "hdfs.h"
#include <arpa/inet.h>
#include <boost/format.h>
#include <boost/log/attributes.hpp>
#include <boost/log/core.hpp>
#include <boost/log/expressions.hpp>
#include <boost/log/sinks/text_file_backend.hpp>
#include <boost/log/sources/logger.hpp>
#include <boost/log/support/date_time.hpp>
#include <boost/log/trivial.hpp>
#include <boost/log/utility/setup/file.hpp>
#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_generators.hpp>
#include <boost/uuid/uuid_io.hpp>
#include <chrono>
#include <cstdlib>
#include <deque>
#include <etcd/Client.hpp>
#include <etcd/Response.hpp>
#include <etcd/Watcher.hpp>
#include <grpcpp/ext/proto_server_reflection_plugin.h>
#include <grpcpp/grpcpp.h>
#include <grpcpp/health_check_service_interface.h>
#include <ifaddrs.h>
#include <iostream>
#include <netinet/in.h>
#include <sys/socket.h>
#include <thread>

namespace logging = boost::log;
namespace sinks = boost::log::sinks;
namespace expr = boost::log::expressions;

using MamaRequest = alimama::proto::Request;
using MamaResponse = alimama::proto::Response;
using SliceRequest = alimama::proto::SliceRequest;
using alimama::proto::ModelService;
using collab::proto::CollabService;
using grpc::ServerContext;
using grpc::Status;

constexpr size_t KB = 1024;
constexpr size_t MB = 1024 * KB;
constexpr size_t QUERY_STEP = 64 * MB; // TODO: optimize this

constexpr int queryInterval = 1000; // microseconds

static bool exiting = false;

const std::string collabUrl = "localhost:50050";
const std::string etcdUrl = "http://etcd:2379";
const std::string etcdPublishTaskPrefix = "/tasks/";
const std::string etcdFinishTaskPrefix = "/finished/";
const std::string etcdServiceDiscoveryFmt = "/service/modeling/%1%";

std::string GetIpAddr() {
  struct ifaddrs *addresses;
  if (getifaddrs(&addresses) == -1) {
    BOOST_LOG_TRIVIAL(error)
        << "server-" << nodeId << " Error occurred in getifaddrs!";
    return "";
  }

  std::string ipAddr;
  for (struct ifaddrs *addr = addresses; addr != nullptr;
       addr = addr->ifa_next) {
    if (addr->ifa_addr == nullptr || addr->ifa_addr->sa_family != AF_INET)
      continue;

    const struct sockaddr_in *sockaddr =
        reinterpret_cast<const struct sockaddr_in *>(addr->ifa_addr);
    ipAddr = inet_ntoa(sockaddr->sin_addr);
    if (strcmp(ipAddr.c_str(), "127.0.0.1") == 0)
      continue;

    BOOST_LOG_TRIVIAL(info)
        << "The local ip address parse succeed, is " << ipAddr;
    break;
  }

  freeifaddrs(addresses);
  return ipAddr;
}

class SliceCache {
private:
  std::string targetPath(int slice) {
    return boost::format("./model_slice.%03d%") % slice;
  }

public:
  std::string version;
  int start;
  int cnt;
  vector<ModelSliceReader *> readers;

  SliceCache(std::string version) : version(version) {}

  void Load() {
    readers.resize(cnt);
    for (int i = 0; i < cnt; i++) {
      readers[i] = new ModelSliceReader();
      readers[i]->Load(targetPath(start + i));
    }
  }

  bool Has(int slice) { return slice >= start && slice < start + cnt; }

  void Unload() {
    for (auto reader : readers) {
      reader->Unload();
      delete reader;
    }
  }

  void Read(int slice, size_t seek, size_t len, char *buffer) {
    readers[slice - start]->Read(seek, len, buffer);
  }
};

std::deque<SliceCache *> sliceCaches;

class EtcdNode {
protected:
  int nodeId;
  int nodeNum;

  EtcdNode(int nodeId, int nodeNum, bool isMaster)
      : nodeId(nodeId), nodeNum(nodeNum) {}

public:
  void Register() {
    etcd::Client client(etcdUrl);
    std::string ipAddr = GetIpAddr();
    auto task = client.set(boost::format(etcdServiceDiscoveryFmt) % ipAddr, "");

    try {
      etcd::Response response = task.get();
      if (response.is_ok())
        BOOST_LOG_TRIVIAL(info) << "Successfully registered";
      else
        BOOST_LOG_TRIVIAL(error)
            << "operation failed, details: " << response.error_message();
    } catch (std::exception const &ex) {
      BOOST_LOG_TRIVIAL(error)
          << "Registration encountered a communication problem, details: "
          << ex.what();
    }
  }
}; // class EtcdNode

void launchCollabRequest() {
  CollabRequest collabRequest;

  collabRequest->set_version(currentVersion);
  // XXX
}

void ReadThread(const SliceRequest *sliceRequest) {
  auto slice = static_cast<int>(sliceRequests[i].slice_partition());
  auto seek = sliceRequests[i].data_start();
  auto len = sliceRequests[i].data_len();

  if (sliceCaches[0].Has(slice)) {
    sliceCaches[0].Read(slice, seek, len, buffer);
  } else {
    launchCollabRequest(slice, seek, len, buffer);
  }
  delete buffer;
}

class CollabServiceImpl final : public CollabService::Service {
public:
  Status Get(ServerContext *context, const CollabRequest *request,
             CollabResponse *reply) override {

    return Status::OK;
  }
}; // CollabServiceImpl

class ModelServiceImpl final : public ModelService::Service {
public:
  Status Get(ServerContext *context, const MamaRequest *request,
             MamaResponse *reply) override {
    const SliceRequest *sliceRequests = &request->slice_request();
    vector<char *> buffers(sliceRequests.size());
    vector<std::thread> threads(sliceRequests.size());

    for (int i = 0; i < sliceRequests.size(); i++) {
      buffers[i] = new char[sliceRequests[i].data_len()];
      threads[i] = std::thread(ReadThread, &sliceRequests[i], buffers[i]);
    }

    for (int i = 0; i < sliceRequests.size(); i++) {
      threads[i].join();
      reply->add_slice_data(buffers[i], sliceRequests[i].data_len());
      delete[] buffers[i];
    }

    reply->set_status(0);
    return Status::OK;
  }
}; // class ModelServiceImpl

void RunExternalGrpc() {
  std::string server_address("0.0.0.0:50051");
  ModelServiceImpl service;

  grpc::EnableDefaultHealthCheckService(true);
  grpc::reflection::InitProtoReflectionServerBuilderPlugin();
  grpc::ServerBuilder grpcServerBuilder;
  grpcServerBuilder.AddListeningPort(server_address,
                                     grpc::InsecureServerCredentials());
  grpcServerBuilder.RegisterService(&service);
  std::unique_ptr<grpc::Server> server(builder.BuildAndStart());
  std::cout << "Server listening on " << server_address << std::endl;

  server->Wait();
  freeBuffer();
}

std::string latestVersion(hdfsFs &fs) {
  constexpr size_t versionBufferSize = 1024;

  int numEntries;
  std::string ret;
  std::vector<std::string> dirs;

  hdfsFileInfo *fileInfo = hdfsListDirectory(fs, "/root", &numEntries);
  if (fileInfo == nullptr || numEntries == 0) {
    ret = "";
    goto cleanup;
  }

  for (int i = 0; i < numEntries; ++i) {
    boost::filesystem::path path(fileInfo[i].mName);
    std::string filename = path.filename().string();

    if (filename == "rollback.version") {
      char buffer[versionBufferSize];

      hdfsFile rbFile = hdfsOpenFile(fs, fileInfo[i].mName, O_RDONLY, 0, 0, 0);
      hdfsRead(fs, rbFile, buffer, versionBufferSize);
      hdfsCloseFile(fs, rbFile);

      ret = std::string(buffer);
      goto cleanup;
    }

    dirs.push_back(std::move(filename));
  }

  // XXX: Does Hadoop API sort the entries? If it does, remove the line below.
  sort(dirs.rbegin(), dirs.rend());
  ret = dirs[0];

cleanup:
  hdfsFreeFileInfo(fileInfo, numEntries);
  return ret;
}

std::string currentVersion;

void downloadModelFromHdfs(std::string version) {}

void loadVersion(std::string version) {
  if (sliceCaches.size() == 2) {
    BOOST_LOG_TRIVIAL(error) << "Versioning error: sliceCaches.size() == 2";
    return;
  }

  sliceCaches.push_back(new SliceCache(version));
  downloadModelFromHdfs(version);
  sliceCaches[1].Load();
  // XXX: sync with other nodes
  currentVersion = version;
}

void Versioning() {
  hdfsFS fs = hdfsConnect("namenode", 9000);

  while (!exiting) {
    std::string newVersion = latestVersion(fs);
    if (currentVersion != newVersion)
      loadVersion(newVersion);
    std::this_thread::sleep_for(std::chrono::microseconds(queryInterval)));
  }

  hdfsDisconnect(fs);
}

void InitLog() {
  // Set up the text file backend with a file name pattern
  // that includes the current date and time
  boost::shared_ptr<sinks::text_file_backend> backend =
      boost::make_shared<sinks::text_file_backend>(
          logging::keywords::file_name = "simple.log");

  // Set the format for log records
  logging::formatter fmt = expr::stream
                           << "["
                           << expr::format_date_time<boost::posix_time::ptime>(
                                  "TimeStamp", "%Y-%m-%d %H:%M:%S.%f")
                           << "] "
                           << "<" << logging::trivial::severity << "> "
                           << expr::smessage;

  // Add the text file backend to the core
  auto sink =
      boost::make_shared<sinks::synchronous_sink<sinks::text_file_backend>>(
          backend);
  sink->set_formatter(fmt);
  logging::core::get()->add_sink(sink);

  // Set the logging level
  logging::core::get()->set_filter(logging::trivial::severity >=
                                   logging::trivial::info);
}

int ParseNodeId() {
  const char *envStr = std::getenv("NODE_ID");
  return std::stoi(envStr);
}

int ParseNodeNum() {
  const char *envStr = std::getenv("NODE_NUM");
  return std::stoi(envStr);
}

int main(int argc, char **argv) {
  const int nodeId = ParseNodeId();
  const int nodeNum = ParseNodeNum();

  InitLog();

  std::thread versioningThread(Versioning);

  // XXX: join these two threads
  StartMaster(nodeId, nodeNum);
  RunExternalGrpc(pMaster);

  exiting = true;
  versioningThread.join();

  return 0;
}
